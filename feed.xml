<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.6">Jekyll</generator><link href="http://www.flinhong.com/feed.xml" rel="self" type="application/atom+xml" /><link href="http://www.flinhong.com/" rel="alternate" type="text/html" /><updated>2016-06-17T20:05:00+08:00</updated><id>http://www.flinhong.com/</id><title>Frank&#39;s Blog</title><subtitle>This blog is an exploration of my quirky thoughts and random adventures through life. I hope you enjoy reading and perusing my posts, please leave me a comment... I&#39;d love to hear from you!</subtitle><author><name>Frank Lin</name></author><entry><title>Git 学习笔记 - 分支</title><link href="http://www.flinhong.com/tools/Git-notes-branch/" rel="alternate" type="text/html" title="Git 学习笔记 - 分支" /><published>2016-06-16T00:00:00+08:00</published><updated>2016-06-16T00:00:00+08:00</updated><id>http://www.flinhong.com/tools/Git-notes-branch</id><content type="html" xml:base="http://www.flinhong.com/tools/Git-notes-branch/">&lt;p&gt;Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。&lt;/p&gt;

&lt;h2 id=&quot;headid-section&quot;&gt;分支简介&lt;/h2&gt;

&lt;p&gt;首先要理解 Git 保存的不是文件的变化或者差异，而是一系列不同时刻的文件快照。&lt;/p&gt;

&lt;p&gt;在进行提交操作时，Git 会保存一个提交对象（commit object）。知道了 Git 保存数据的方式，我们可以很自然的想到——该提交对象会包含一个指向暂存内容快照的指针。但不仅仅是这样，该提交对象还包含了作者的姓名和邮箱、提交时输入的信息以及指向它的父对象的指针。首次提交产生的提交对象没有父对象，普通提交操作产生的提交对象有一个父对象，而由多个分支合并产生的提交对象有多个父对象。&lt;/p&gt;

&lt;p&gt;我们假设现在有一个工作目录，里面包含了三个将要被暂存和提交的文件。暂存操作会为每一个文件计算校验和，然后会把当前版本的文件快照保存到 Git 仓库中（Git 使用 &lt;a href=&quot;https://en.wikipedia.org/wiki/Binary_large_object&quot;&gt;blob&lt;/a&gt; 对象来保存它们），最终将校验和加入到暂存区域等待提交：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add README test.rb LICENSE
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -m &lt;span class=&quot;s1&quot;&gt;&#39;The initial commit of my project&#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;当使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 进行提交操作时，Git 会先计算每一个子目录的校验和，然后在 Git 仓库中这些校验和保存为树对象。 随后，Git 便会创建一个提交对象，它除了包含上面提到的那些信息外，还包含指向这个树对象（项目根目录）的指针。如此一来，Git 就可以在需要的时候重现此次保存的快照。&lt;/p&gt;

&lt;p&gt;现在，Git 仓库中有五个对象：三个 blob 对象（保存着文件快照）、一个树对象（记录着目录结构和 blob 对象索引）以及一个提交对象（包含着指向前述树对象的指针和所有提交信息）。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/commit-and-tree.png&quot; alt=&quot;Git-tree&quot; title=&quot;首次提交对象及其树结构&quot; /&gt;&lt;/p&gt;

&lt;p&gt;做些修改后再次提交，那么这次产生的提交对象会包含一个指向上次提交对象（父对象）的指针。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/commits-and-parents.png&quot; alt=&quot;git-tree-parents&quot; title=&quot;提交对象及其父对象&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git 的分支，其实本质上仅仅是指向提交对象的可变指针。Git 的默认分支名字是 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;。在多次提交操作之后，你其实已经有一个指向最后那个提交对象的 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支。它会在每次的提交操作中自动向前移动。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/201606/branch-and-history.png&quot; alt=&quot;branch and histroy&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;headid-section-1&quot;&gt;分支创建&lt;/h2&gt;

&lt;p&gt;Git 创建分支很简单，它只是为你创建了一个可以移动的新的指针。比如，创建一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;testing&lt;/code&gt; 分支，你只需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt; 命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git branch testing
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这会在当前所在的提交对象上创建一个指针。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/two-branches.png&quot; alt=&quot;branches&quot; title=&quot;两个指向相同提交历史的分支&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么，Git 又是怎么知道当前在哪一个分支上呢？ 也很简单，它有一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 的特殊指针。在 Git 中，它是一个指针，指向当前所在的本地分支（可将 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 想象为当前分支的别名）。在这里，你仍然在 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支上。因为 &lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt; 命令仅仅 &lt;strong&gt;创建&lt;/strong&gt; 一个新分支，并不会自动切换到新分支中去。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/head-to-master.png&quot; alt=&quot;Head to branch&quot; title=&quot;HEAD 指向当前所在的分支&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你可以简单地使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 命令查看各个分支当前所指的对象。提供这一功能的参数是 &lt;code class=&quot;highlighter-rouge&quot;&gt;--decorate&lt;/code&gt;。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git log --oneline --decorate
f30ab &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;HEAD, master, testing&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; add feature &lt;span class=&quot;c&quot;&gt;#32 - ability to add new&lt;/span&gt;
34ac2 fixed bug &lt;span class=&quot;c&quot;&gt;#1328 - stack overflow under certain conditions&lt;/span&gt;
98ca9 initial commit of my project
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;正如你所见，当前 “master” 和 “testing” 分支均指向校验和以 &lt;code class=&quot;highlighter-rouge&quot;&gt;f30ab&lt;/code&gt; 开头的提交对象。&lt;/p&gt;

&lt;h2 id=&quot;headid-section-2&quot;&gt;分支切换&lt;/h2&gt;

&lt;p&gt;要切换到一个已存在的分支，你需要使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout&lt;/code&gt; 命令。 我们现在切换到新创建的 &lt;code class=&quot;highlighter-rouge&quot;&gt;testing&lt;/code&gt; 分支去：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout testing
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这样 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 就指向 &lt;code class=&quot;highlighter-rouge&quot;&gt;testing&lt;/code&gt; 分支了。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/head-to-testing.png&quot; alt=&quot;head to a branch&quot; title=&quot;切换分支后，HEAD 指向当前所在的分支&quot; /&gt;&lt;/p&gt;

&lt;p&gt;那么，这样的实现方式会给我们带来什么好处呢？现在不妨再提交一次：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;vim test.rb
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s1&quot;&gt;&#39;made a change&#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/advance-testing.png&quot; alt=&quot;移动head&quot; title=&quot;HEAD 分支随着提交操作自动向前移动&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图所示，你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;testing&lt;/code&gt; 分支向前移动了，但是 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支却没有，它仍然指向运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout&lt;/code&gt; 时所指的对象。这就有意思了，现在我们切换回 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支看看：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout master
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/checkout-master.png&quot; alt=&quot;切换分支&quot; title=&quot;checkout 时，HEAD 随之移动&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这条命令做了两件事。一是使 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 指回 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支，二是将工作目录恢复成 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支所指向的快照内容。也就是说，你现在做修改的话，项目将始于一个较旧的版本。本质上来讲，这就是忽略 &lt;code class=&quot;highlighter-rouge&quot;&gt;testing&lt;/code&gt; 分支所做的修改，以便于向另一个方向进行开发。&lt;/p&gt;

&lt;div class=&quot;info-message&quot;&gt;
  &lt;a href=&quot;#&quot; class=&quot;close-info&quot;&gt;&lt;i class=&quot;fa fa-times&quot;&gt;&lt;/i&gt;&lt;/a&gt;
  &lt;p&gt;&lt;strong&gt;分支切换会改变你工作目录中的文件&lt;/strong&gt;&lt;/p&gt;
  &lt;p&gt;在切换分支时，一定要注意你工作目录里的文件会被改变。如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。如果 Git 不能干净利落地完成这个任务，它将禁止切换分支。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;我们再稍微做些修改并提交：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;vim test.rb
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s1&quot;&gt;&#39;made other changes&#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在，这个项目的提交历史已经产生了分叉。因为刚才你创建了一个新分支，并切换过去进行了一些工作，随后又切换回旧的 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支进行了另外一些工作。上述两次改动针对的是不同分支：你可以在不同分支间不断地来回切换和工作，并在需要时将它们合并起来。而所有这些工作，你需要的命令只有 &lt;code class=&quot;highlighter-rouge&quot;&gt;branch&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;checkout&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt;。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/advance-master.png&quot; alt=&quot;项目分叉&quot; title=&quot;项目分叉历史&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你可以简单地使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 命令查看分叉历史。运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log --oneline --decorate --graph --all&lt;/code&gt; ，它会输出你的提交历史、各个分支的指向以及项目的分支分叉情况。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git log --oneline --decorate --graph --all
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; c2b9e &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;HEAD, master&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; made other changes
| &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 87ab2 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;testing&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; made a change
|/
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; f30ab add feature &lt;span class=&quot;c&quot;&gt;#32 - ability to add new formats to the&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 34ac2 fixed bug &lt;span class=&quot;c&quot;&gt;#1328 - stack overflow under certain conditions&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 98ca9 initial commit of my project
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;由于 Git 的分支实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都异常高效。创建一个新分支就像是往一个文件中写入 41 个字节（40 个字符和 1 个换行符），如此的简单能不快吗？&lt;/p&gt;

&lt;h2 id=&quot;headid-section-3&quot;&gt;分支的新建与合并&lt;/h2&gt;

&lt;h3 id=&quot;headid-section-4&quot;&gt;新建分支&lt;/h3&gt;

&lt;p&gt;首先，我们假设你正在你的项目上工作，并且已经有一些提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/201606/basic-branching-1.png&quot; alt=&quot;basic branch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，你已经决定要解决追踪系统中的 #53 问题。想要新建一个分支并同时切换到那个分支上，你可以运行一个带有 &lt;code class=&quot;highlighter-rouge&quot;&gt;-b&lt;/code&gt; 参数的 &lt;code class=&quot;highlighter-rouge&quot;&gt;git checkout&lt;/code&gt; 命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout -b iss53
Switched to a new branch &lt;span class=&quot;s2&quot;&gt;&quot;iss53&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它是下面两条命令的简写：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git branch iss53
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout iss53
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/images/201606/basic-branching-2.png&quot; alt=&quot;创建一个分支&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你继续在 #53 问题上工作，并且做了一些提交。在此过程中，&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支在不断的向前推进，因为你已经检出到该分支（也就是说，你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 指针指向了 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支）。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;vim index.html
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s1&quot;&gt;&#39;added a new footer [issue 53]&#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/basic-branching-3.png&quot; alt=&quot;前进分支&quot; title=&quot;iss53 分支随着工作的进展向前推进&quot; /&gt;&lt;/p&gt;

&lt;p&gt;现在，突然有个紧急问题等待你来解决。有了 Git 的帮助，你不必把这个紧急问题和 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 的修改混在一起，你也不需要花大力气来还原关于 #53 问题的修改。你所要做的仅仅是切换回 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支。&lt;/p&gt;

&lt;p&gt;但是，在你这么做之前，要留意你的工作目录和暂存区里那些还没有被提交的修改，它可能会和你即将检出的分支产生冲突从而阻止 Git 切换到该分支。最好的方法是，在你切换分支之前，保持好一个干净的状态。现在，我们假设你已经把你的修改全部提交了，这时你可以切换回 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支了：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout master
Switched to branch &lt;span class=&quot;s1&quot;&gt;&#39;master&#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个时候，你的工作目录和你在开始 #53 问题之前一模一样，现在你可以专心修复紧急问题了。请牢记：当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样。&lt;/p&gt;

&lt;p&gt;接下来，你要修复这个紧急问题。让我们建立一个针对该紧急问题的分支（hotfix branch），在该分支上工作直到问题解决：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout -b hotfix
Switched to a new branch &lt;span class=&quot;s1&quot;&gt;&#39;hotfix&#39;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;vim index.html
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s1&quot;&gt;&#39;fixed the broken email address&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;hotfix 1fb7853] fixed the broken email address
 1 file changed, 2 insertions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/basic-branching-4.png&quot; alt=&quot;new branch&quot; title=&quot;基于 master 分支的紧急问题分支 hotfix branch&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你可以运行你的测试，确保你的修改是正确的，然后将修改后的版本其合并回你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt;。你可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 命令来达到上述目的：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout master
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git merge hotfix
Updating f42c576..3a0874c
Fast-forward
 index.html | 2 ++
 1 file changed, 2 insertions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在合并的时候，你应该注意到了”快进（fast-forward）”这个词。由于当前 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支所指向的提交是你当前提交（有关 hotfix 的提交）的直接上游，所以 Git 只是简单的将指针向前移动。换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移），因为这种情况下的合并操作没有需要解决的分歧——这就叫做 “快进（fast-forward）”。&lt;/p&gt;

&lt;p&gt;现在，最新的修改已经在 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支所指向的提交快照中，你可以着手发布该修复了。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/basic-branching-5.png&quot; alt=&quot;update master branch&quot; title=&quot;master 分支被快进到 hotfix&quot; /&gt;&lt;/p&gt;

&lt;p&gt;关于这个紧急问题的解决方案发布之后，你准备回到被打断之前时的工作中。然而，你应该先删除 &lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt; 分支，因为你已经不再需要它了 —— &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支已经指向了同一个位置。你可以使用带 &lt;code class=&quot;highlighter-rouge&quot;&gt;-d&lt;/code&gt; 选项的 &lt;code class=&quot;highlighter-rouge&quot;&gt;git branch&lt;/code&gt; 命令来删除分支：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git branch -d hotfix
Deleted branch hotfix &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;3a0874c&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在你可以切换回你正在工作的分支继续你的工作，也就是针对 #53 问题的那个分支（&lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支）。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout iss53
Switched to branch &lt;span class=&quot;s2&quot;&gt;&quot;iss53&quot;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;vim index.html
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s1&quot;&gt;&#39;finished the new footer [issue 53]&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;iss53 ad82d7a] finished the new footer &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;issue 53]
1 file changed, 1 insertion&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/basic-branching-6.png&quot; alt=&quot;再回到修改分支&quot; title=&quot;切换到 iss53 分支上继续工作&quot; /&gt;&lt;/p&gt;

&lt;p&gt;你在 &lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt; 分支上所做的工作并没有包含到 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支中。如果你需要拉取 &lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt; 所做的修改，你可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git merge master&lt;/code&gt; 命令将 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支合并入 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支，或者你也可以等到 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支完成其使命，再将其合并回 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-5&quot;&gt;分支的合并&lt;/h3&gt;

&lt;p&gt;假设你已经修正了 #53 问题，并且打算将你的工作合并入 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支。为此，你需要合并 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支到 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支，这和之前你合并 &lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt; 分支所做的工作差不多。你只需要检出到你想合并入的分支，然后运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git merge&lt;/code&gt; 命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout master
Switched to branch &lt;span class=&quot;s1&quot;&gt;&#39;master&#39;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git merge iss53
Merge made by the &lt;span class=&quot;s1&quot;&gt;&#39;recursive&#39;&lt;/span&gt; strategy.
index.html |    1 +
1 file changed, 1 insertion&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这和你之前合并 &lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt; 分支的时候看起来有一点不一样。在这种情况下，你的开发历史从一个更早的地方开始分叉开来（diverged）。因为，&lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支所在提交并不是 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支所在提交的直接祖先，Git 不得不做一些额外的工作。出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C2），做一个简单的三方合并，如下图：&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201606/basic-merging-1.png&quot; alt=&quot;合并&quot; title=&quot;一次典型合并中所用到的三个快照&quot; /&gt;&lt;/p&gt;

&lt;p&gt;和之前将分支指针向前推进所不同的是，Git 将此次三方合并的结果做了一个新的快照并且自动创建一个新的提交指向它。这个被称作一次合并提交，它的特别之处在于他有不止一个父提交。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/201606/basic-merging-2.png&quot; alt=&quot;合并提交&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git 会自行决定选取哪一个提交作为最优的共同祖先，并以此作为合并的基础。&lt;/p&gt;

&lt;p&gt;既然你的修改已经合并进来了，你已经不再需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支了。现在你可以在任务追踪系统中关闭此项任务，并删除这个分支。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-6&quot;&gt;遇到冲突时的分支合并&lt;/h3&gt;

&lt;p&gt;有时候合并操作不会如此顺利。如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。如果你对 #53 问题的修改和有关 &lt;code class=&quot;highlighter-rouge&quot;&gt;hotfix&lt;/code&gt; 的修改都涉及到同一个文件的同一处，在合并它们的时候就会产生合并冲突：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git merge iss53
Auto-merging index.html
CONFLICT &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;content&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;: Merge conflict &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;index.html
Automatic merge failed; fix conflicts and &lt;span class=&quot;k&quot;&gt;then &lt;/span&gt;commit the result.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时 Git 做了合并，但是没有自动地创建一个新的合并提交。Git 会暂停下来，等待你去解决合并产生的冲突。你可以在合并冲突后的任意时刻使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令来查看那些因包含合并冲突而处于未合并（unmerged）状态的文件：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
You have unmerged paths.
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;fix conflicts and run &lt;span class=&quot;s2&quot;&gt;&quot;git commit&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

Unmerged paths:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to mark resolution&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    both modified:      index.html

no changes added to commit &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add&quot;&lt;/span&gt; and/or &lt;span class=&quot;s2&quot;&gt;&quot;git commit -a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;任何因包含合并冲突而有待解决的文件，都会以未合并状态标识出来。Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&amp;lt;&lt;/span&gt;&amp;lt; HEAD:index.html
&amp;lt;div &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;footer&quot;&lt;/span&gt;&amp;gt;contact : email.support@github.com&amp;lt;/div&amp;gt;
&lt;span class=&quot;o&quot;&gt;=======&lt;/span&gt;
&amp;lt;div &lt;span class=&quot;nv&quot;&gt;id&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;footer&quot;&lt;/span&gt;&amp;gt;
 please contact us at support@github.com
&amp;lt;/div&amp;gt;
&lt;span class=&quot;gp&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;iss53:index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这表示 &lt;code class=&quot;highlighter-rouge&quot;&gt;HEAD&lt;/code&gt; 所指示的版本（也就是你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;master&lt;/code&gt; 分支所在的位置，因为你在运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;merge&lt;/code&gt; 命令的时候已经检出到了这个分支）在这个区段的上半部分（&lt;code class=&quot;highlighter-rouge&quot;&gt;=======&lt;/code&gt; 的上半部分），而 &lt;code class=&quot;highlighter-rouge&quot;&gt;iss53&lt;/code&gt; 分支所指示的版本在 &lt;code class=&quot;highlighter-rouge&quot;&gt;=======&lt;/code&gt; 的下半部分。为了解决冲突，你必须选择使用由 &lt;code class=&quot;highlighter-rouge&quot;&gt;=======&lt;/code&gt; 分割的两部分中的一个，或者你也可以自行合并这些内容。例如，你可以通过把这段内容换成下面的样子来解决冲突：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git mergetool

This message is displayed because &lt;span class=&quot;s1&quot;&gt;&#39;merge.tool&#39;&lt;/span&gt; is not configured.
See &lt;span class=&quot;s1&quot;&gt;&#39;git mergetool --tool-help&#39;&lt;/span&gt; or &lt;span class=&quot;s1&quot;&gt;&#39;git help config&#39;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;more details.
&lt;span class=&quot;s1&quot;&gt;&#39;git mergetool&#39;&lt;/span&gt; will now attempt to use one of the following tools:
opendiff kdiff3 tkdiff xxdiff meld tortoisemerge gvimdiff diffuse diffmerge ecmerge p4merge araxis bc3 codecompare vimdiff emerge
Merging:
index.html

Normal merge conflict &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;index.html&#39;&lt;/span&gt;:
  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;: modified file
  &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;remote&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;: modified file
Hit &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;to start merge resolution tool &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;opendiff&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;:
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你想使用除默认合并工具外的其他合并工具，你可以在 “下列工具中（one of the following tools）” 这句后面看到所有支持的合并工具。 然后输入你喜欢的工具名字就可以了。&lt;/p&gt;

&lt;p&gt;等你退出合并工具之后，Git 会询问刚才的合并是否成功。如果你回答是，Git 会暂存那些文件以表明冲突已解决：你可以再次运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 来确认所有的合并冲突都已被解决：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
All conflicts fixed but you are still merging.
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git commit&quot;&lt;/span&gt; to conclude merge&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

Changes to be committed:

    modified:   index.html
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你对结果感到满意，并且确定之前有冲突的的文件都已经暂存了，这时你可以输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 来完成合并提交。默认情况下提交信息看起来像下面这个样子：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Merge branch &lt;span class=&quot;s1&quot;&gt;&#39;iss53&#39;&lt;/span&gt;

Conflicts:
    index.html
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# It looks like you may be committing a merge.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# If this is not correct, please remove the file&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# .git/MERGE_HEAD&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# and try again.&lt;/span&gt;


&lt;span class=&quot;c&quot;&gt;# Please enter the commit message for your changes. Lines starting&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# with &#39;#&#39; will be ignored, and an empty message aborts the commit.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# On branch master&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# All conflicts fixed but you are still merging.&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Changes to be committed:&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# modified:   index.html&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;#&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;好了，先到这里了，这下终于明白为什么有时候会遇到冲突。之前不懂解决，总是去拷贝一份之前的数据，重新修改，秀逗了……&lt;/p&gt;</content><author><name>Frank Lin</name></author><category term="Tools" /><category term="Git" /><summary>Git 处理分支的方式可谓是难以置信的轻量，创建新分支这一操作几乎能在瞬间完成，并且在不同分支之间的切换操作也是一样便捷。与许多其它版本控制系统不同，Git 鼓励在工作流程中频繁地使用分支与合并，哪怕一天之内进行许多次。理解和精通这一特性，你便会意识到 Git 是如此的强大而又独特，并且从此真正改变你的开发方式。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201606/git-icons.png" /></entry><entry><title>Git 学习笔记 - 撤销操作</title><link href="http://www.flinhong.com/tools/Git-notes-reset/" rel="alternate" type="text/html" title="Git 学习笔记 - 撤销操作" /><published>2016-06-14T00:00:00+08:00</published><updated>2016-06-14T00:00:00+08:00</updated><id>http://www.flinhong.com/tools/Git-notes-reset</id><content type="html" xml:base="http://www.flinhong.com/tools/Git-notes-reset/">&lt;p&gt;今天学习一下 Git 中的撤销操作，尤其需要注意有些撤销操作是不可逆的，这也是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有几个地方之一。&lt;/p&gt;

&lt;p&gt;练习操作还是可以继续克隆这个仓库：&lt;code class=&quot;highlighter-rouge&quot;&gt;https://github.com/libgit2/libgit2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 &lt;code class=&quot;highlighter-rouge&quot;&gt;--amend&lt;/code&gt; 选项的提交命令尝试重新提交：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个命令会将暂存区中的文件提交。 如果自上次提交以来你还未做任何修改（例如，在上次提交后马上执行了此命令），那么快照会保持不变，而你所修改的只是提交信息。&lt;/p&gt;

&lt;p&gt;例如，你提交后发现忘记了暂存某些需要的修改，可以像下面这样操作：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -m &lt;span class=&quot;s1&quot;&gt;&#39;initial commit&#39;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add forgotten_file
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit --amend
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最终你只会有一个提交，第二次提交将代替第一次提交的结果。&lt;/p&gt;

&lt;h2 id=&quot;headid-section&quot;&gt;取消暂存的文件&lt;/h2&gt;

&lt;p&gt;如果你已经修改了两个文件并且想要将它们作为两次独立的修改提交，但是却意外地输入了 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add *&lt;/code&gt; 暂存了它们两个。如何只取消暂存两个中的一个呢？ &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令提示了你：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
Changes to be committed:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git reset HEAD &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to unstage&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    renamed:    README.md -&amp;gt; README
    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在 “Changes to be committed” 文字正下方，提示使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git reset HEAD &amp;lt;file&amp;gt;...&lt;/code&gt; 来取消暂存。所以，我们可以这样用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git reset&lt;/code&gt; 来取消暂存 &lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt; 文件：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git reset HEAD CONTRIBUTING.md
Unstaged changes after reset:
M	CONTRIBUTING.md
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
Changes to be committed:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git reset HEAD &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to unstage&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    renamed:    README.md -&amp;gt; README

Changes not staged &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;commit:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to update what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git checkout -- &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to discard changes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;working directory&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这个命令有点儿奇怪，但是起作用了。 &lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt; 文件已经是修改未暂存的状态了。&lt;/p&gt;

&lt;h2 id=&quot;headid-section-1&quot;&gt;撤消对文件的修改&lt;/h2&gt;

&lt;p&gt;如果你并不想保留对 &lt;code class=&quot;highlighter-rouge&quot;&gt;CONTRIBUTING.md&lt;/code&gt; 文件的修改怎么办？ 你该如何方便地撤消修改 —— 将它还原成上次提交时的样子（或者刚克隆完的样子，或者刚把它放入工作目录时的样子）？幸运的是，&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 也告诉了你应该如何做。在上面一个例子中，未暂存区域是这样：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Changes not staged &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;commit:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to update what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git checkout -- &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to discard changes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;working directory&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    modified:   CONTRIBUTING.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它非常清楚地告诉了你如何撤消之前所做的修改。 让我们来按照提示执行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git checkout -- CONTRIBUTING.md
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
Changes to be committed:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git reset HEAD &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to unstage&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    renamed:    README.md -&amp;gt; README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;可以看到那些修改已经被撤消了。&lt;/p&gt;

&lt;div class=&quot;info-message&quot;&gt;
	&lt;a href=&quot;#&quot; class=&quot;close-info&quot;&gt;&lt;i class=&quot;fa fa-times&quot;&gt;&lt;/i&gt;&lt;/a&gt;
	&lt;p&gt;&lt;strong&gt;注意:&lt;/strong&gt;&lt;/p&gt;
	&lt;p&gt;你需要知道 &quot;git checkout -- [file]&quot; 是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 —— 你只是拷贝了另一个文件来覆盖它。 除非你确实清楚不想要那个文件了，否则不要使用这个命令。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;另外，在 Git 中任何 &lt;strong&gt;已提交的&lt;/strong&gt; 东西几乎总是可以恢复的。 甚至那些被删除的分支中的提交或使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--amend&lt;/code&gt; 选项覆盖的提交也可以恢复。 然而，任何你未提交的东西丢失后很可能再也找不到了。&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;&lt;/p&gt;

&lt;p&gt;引用：&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://git-scm.com/book/zh/v2/Git-%E5%9F%BA%E7%A1%80-%E6%92%A4%E6%B6%88%E6%93%8D%E4%BD%9C&quot;&gt;2.4 Git 基础 - 撤消操作&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Frank Lin</name></author><category term="Tools" /><category term="Git" /><summary>今天学习一下 Git 中的撤销操作，尤其需要注意有些撤销操作是不可逆的，这也是在使用 Git 的过程中，会因为操作失误而导致之前的工作丢失的少有几个地方之一。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201606/reset-concept.png" /></entry><entry><title>Anna Kendrick - Cups</title><link href="http://www.flinhong.com/media/Anna-Kendrick-Cups/" rel="alternate" type="text/html" title="Anna Kendrick - Cups" /><published>2016-06-12T00:00:00+08:00</published><updated>2016-06-12T00:00:00+08:00</updated><id>http://www.flinhong.com/media/Anna-Kendrick-Cups</id><content type="html" xml:base="http://www.flinhong.com/media/Anna-Kendrick-Cups/">&lt;p&gt;这首歌本是 A. P. Carter 在 20 世纪 30 年代所创作的一首老歌，名叫《若我离开了》(“When I’m Gone”)。后由多人先后反复修改，加入了击杯元素并修改了填词，最后由美国演员 Anna Kendrick 在电影 &lt;em&gt;Pitch Perfect&lt;/em&gt; 中唱红。&lt;/p&gt;

&lt;p&gt;歌词很简单，但是击杯游戏很有意思，吸引了大部分眼球。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;I got my ticket for the long way round&lt;/p&gt;

  &lt;p&gt;The one with the prettiest of views&lt;/p&gt;

  &lt;p&gt;It’s got mountains&lt;/p&gt;

  &lt;p&gt;It’s got rivers&lt;/p&gt;

  &lt;p&gt;It’s got sights to give you shivers
But it sure would be prettier with you&lt;/p&gt;

  &lt;p&gt;When I’m gone&lt;/p&gt;

  &lt;p&gt;When I’m gone&lt;/p&gt;

  &lt;p&gt;You’re gonna miss me when I’m gone&lt;/p&gt;

  &lt;p&gt;You’re gonna miss me by my walk&lt;/p&gt;

  &lt;p&gt;You’re gonna miss me by my talk, oh&lt;/p&gt;

  &lt;p&gt;You’re gonna miss me when I’m gone&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;电影中这段也挺好玩的：&lt;/p&gt;

&lt;iframe width=&quot;853&quot; height=&quot;480&quot; src=&quot;https://www.youtube.com/embed/weqDCGg0GYs&quot; frameborder=&quot;0&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;</content><author><name>Frank Lin</name></author><category term="Media" /><category term="movie" /><category term="music" /><summary>这首歌本是 A. P. Carter 在 20 世纪 30 年代所创作的一首老歌，名叫《若我离开了》(“When I’m Gone”)。后由多人先后反复修改，加入了击杯元素并修改了填词，最后由美国演员 Anna Kendrick 在电影 Pitch Perfect 中唱红。</summary></entry><entry><title>Git 学习笔记 - .gitignore 的使用</title><link href="http://www.flinhong.com/tools/Git-notes-ignore/" rel="alternate" type="text/html" title="Git 学习笔记 - .gitignore 的使用" /><published>2016-06-12T00:00:00+08:00</published><updated>2016-06-12T00:00:00+08:00</updated><id>http://www.flinhong.com/tools/Git-notes-ignore</id><content type="html" xml:base="http://www.flinhong.com/tools/Git-notes-ignore/">&lt;p&gt;项目中经常会生成一些 Git 系统不需要追踪的文件。典型的是在编译生成过程中产生的文件或是编程器生成的临时备份文件。当然，你不追踪这些文件，可以不用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 把它们加到索引中。但是这样会很快变成一件烦人的事，你发现项目中到处有未追踪的文件; 这样也使 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add .&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -a&lt;/code&gt; 变得没有实际用处，同时 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令的输出也会有它们，每次都看到 &lt;code class=&quot;highlighter-rouge&quot;&gt;Untracked files ...&lt;/code&gt; 是不是会变得很抓狂。&lt;/p&gt;

&lt;p&gt;其实，这个问题解决起来很简单，我们可以创建一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 的特殊文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。之前在学习 &lt;a href=&quot;/tools/Git-notes-basics/#headid-section-7&quot;&gt;Git 基础&lt;/a&gt;的时候就谈过这个问题。&lt;/p&gt;

&lt;p&gt;当然，我们不需要从头写 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 文件，GitHub 已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：&lt;a href=&quot;https://github.com/github/gitignore&quot;&gt;https://github.com/github/gitignore&lt;/a&gt;，另外，推荐一个自动生成 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 文件的网址：&lt;a href=&quot;https://www.gitignore.io/&quot;&gt;http://www.gitignore.io/&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;要注意，我们忽略文件的原则是&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;忽略操作系统自动生成的文件，比如缩略图等；&lt;/li&gt;
  &lt;li&gt;忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 .class 文件；&lt;/li&gt;
  &lt;li&gt;忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;比如说，你在 Windows 下进行 Python 开发，Windows 会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有 &lt;code class=&quot;highlighter-rouge&quot;&gt;Desktop.ini&lt;/code&gt; 文件，因此你需要忽略 Windows 自动生成的信息文件：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Windows:
Thumbs.db
ehthumbs.db
Desktop.ini
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后，继续忽略 Python 编译产生的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.pyc&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;.pyo&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;dist&lt;/code&gt; 等文件或目录：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;# Python:
*.py[cod]
*.so
*.egg
*.egg-info
dist
build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后一步就是把 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 也提交到 Git，并且可以对其做版本管理。当然检验 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 的标准是 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令是不是说 &lt;code class=&quot;highlighter-rouge&quot;&gt;working directory clean&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;有些时候，你想添加一个文件到 Git，但发现添加不了，原因可能就是这个文件被 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 忽略了：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add App.class
The following paths are ignored by one of your .gitignore files:
App.class
Use -f &lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;you really want to add them.
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果你确实想添加该文件，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt; 强制添加到 Git：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add -f App.class
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;或者你发现，可能是 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 写得有问题，需要找出来到底哪个规则写错了，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git check-ignore&lt;/code&gt; 命令检查：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git check-ignore -v App.class
.gitignore:3:*.class    App.class
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;上面，Git 告诉我们，&lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则了。&lt;/p&gt;

&lt;p&gt;其他信息可以直接 &lt;code class=&quot;highlighter-rouge&quot;&gt;man gitignore&lt;/code&gt; 查看帮助&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;。&lt;/p&gt;

&lt;p&gt;但有些时候我们会遇到这样的问题：写入 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 文件中的文件却还是被 Git 追踪, 当你通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 查询文件状态时，他们并没有被忽略。&lt;/p&gt;

&lt;p&gt;以下是你可能遇到问题的场景：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;当你在 git 库中编写某些代码文件，并已经 stage 该文件之后，你发现某个文件你不想用了，想在以后的改变中忽略它。然后在你的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 文件中加入该文件名，结果它并没有被忽略。&lt;/li&gt;
  &lt;li&gt;当你从远程代码库中 &lt;code class=&quot;highlighter-rouge&quot;&gt;git clone&lt;/code&gt; 一份代码到本地并做些修改，build，然后通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add .&lt;/code&gt; 等 stage 了这些改变，当你通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 查看状态时发现不小心把 &lt;code class=&quot;highlighter-rouge&quot;&gt;build/&lt;/code&gt; 文件夹给 add 进来了。于是你在 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 文件中加入了 &lt;code class=&quot;highlighter-rouge&quot;&gt;build/&lt;/code&gt;，但发现并不起作用。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;究其原因，&lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 文件只是 ignore 没有被 staged(cached) 文件，对于已经被 staged 的文件，加入 ignore 文件时一定要先从 staged 移除。下面这段话来自 GitHub：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;If you already have a file checked in, and you want to ignore it, Git will not ignore the file if you add a rule later. In those cases, you must untrack the file first, by running the following command in your terminal:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git rm --cached 
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;因此，要想用 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 成功忽略文件，必须先把它们从 staged 中移除&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;commit 你已有的改变，保存当前的工作。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm --cached file/path/to/be/ignored&lt;/code&gt; 清除缓存。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git add .&lt;/code&gt; 添加更改变化。&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git commit -m &quot;fixed untracked files&quot;&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;参考：&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000/0013758404317281e54b6f5375640abbb11e67be4cd49e0000&quot;&gt;忽略特殊文件&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000000522997&quot;&gt;.gitignore 文件使用说明&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://t.hengwei.me/post/gitignore%E6%96%87%E4%BB%B6%E4%B8%8D%E8%B5%B7%E4%BD%9C%E7%94%A8/&quot;&gt;.gitignore 文件不起作用&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Frank Lin</name></author><category term="Tools" /><category term="Git" /><summary>项目中经常会生成一些 Git 系统不需要追踪的文件。典型的是在编译生成过程中产生的文件或是编程器生成的临时备份文件。当然，你不追踪这些文件，可以不用 git add 把它们加到索引中。但是这样会很快变成一件烦人的事，你发现项目中到处有未追踪的文件; 这样也使 git add . 和 git commit -a 变得没有实际用处，同时 git status 命令的输出也会有它们，每次都看到 Untracked files ... 是不是会变得很抓狂。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201606/ignore.jpg" /></entry><entry><title>使用 GitLab CI 自动部署博客到 GitHub Pages</title><link href="http://www.flinhong.com/tips/automated-blog-with-gitlab-ci/" rel="alternate" type="text/html" title="使用 GitLab CI 自动部署博客到 GitHub Pages" /><published>2016-05-22T00:00:00+08:00</published><updated>2016-05-22T00:00:00+08:00</updated><id>http://www.flinhong.com/tips/automated-blog-with-gitlab-ci</id><content type="html" xml:base="http://www.flinhong.com/tips/automated-blog-with-gitlab-ci/">&lt;p&gt;由于一些莫名其妙的原因，我用 GitHub Pages 的 Jekyll 版本不能在本地生成 _posts 的静态文件，自然放到 GitHub 上也不行。一直没弄清楚原因，😳 求知情人士解答。于是找了备用方案，用起了 &lt;a href=&quot;http://docs.gitlab.com/ee/pages/README.html&quot;&gt;GitLab Pages&lt;/a&gt;，但是访问速度上又没有 GitHub Pages 给力，又不想用其他 CDN，所以还是两头托管，还能让百度索引。&lt;/p&gt;

&lt;p&gt;其实 GitLab Pages 是基于 GitLab CI，我们最终看到的网站是借由所配置的 &lt;a href=&quot;http://doc.gitlab.com/ee/ci/quick_start/README.html#configuring-a-runner&quot;&gt;Runner&lt;/a&gt; 生成的，所以可以用各种 Jekyll 插件，还能自定所使用的 Jekyll 版本。搭建起来和 GitHub Pages 差不多，可以参看官方博客 &lt;a href=&quot;https://about.gitlab.com/2016/04/07/gitlab-pages-setup/&quot;&gt;Hosting on GitLab.com with GitLab Pages&lt;/a&gt; 设置就行。&lt;/p&gt;

&lt;p&gt;为了省事，还可以进一步配置 GitLab Pages 所用到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitlab-ci.yml&lt;/code&gt; 文件，让 GitLab 中生成的静态文件自动部署到 GitHub 上，再也不用两个仓库倒腾了。&lt;/p&gt;

&lt;p&gt;首先，需要在 GitHub 中生成一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;Personal access tokens&lt;/code&gt;，注意生成后自己拷贝下来，因为你以后在 GitHub 上不会再见到这个 token 了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/images/201605/github-settings.png&quot; alt=&quot;GitHub access token&quot; /&gt;&lt;/p&gt;

&lt;p&gt;然后就是配置 GitLab 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitlab-ci.yml&lt;/code&gt; 文件，比如说我的：&lt;/p&gt;

&lt;div class=&quot;language-yaml highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;# requiring the environment of Ruby 2.x&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;image&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;ruby:2.2&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;# add bundle cache to &#39;vendor&#39; for speeding up builds&lt;/span&gt;
&lt;span class=&quot;s&quot;&gt;cache&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; 
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;vendor/&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;before_script&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle install --path vendor&lt;/span&gt;

&lt;span class=&quot;s&quot;&gt;pages&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;stage&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;deploy&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;script&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git clone https://&amp;lt;your_github_token&amp;gt;@github.com/&amp;lt;your_github_repo.git&amp;gt; public&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;bundle exec jekyll build -d public/&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;cd ./public&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git config user.name &quot;Frank Lin&quot;&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git config user.email &quot;franklin@flinhong.com&quot;&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git config --global push.default simple&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git add .&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git commit -m &quot;Update site&quot;&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;git push --set-upstream &quot;&amp;lt;your_github_token&amp;gt;@github.com/&amp;lt;your_github_repo.git&amp;gt;&quot;&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;artifacts&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;s&quot;&gt;paths&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;public&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;only&lt;/span&gt;&lt;span class=&quot;pi&quot;&gt;:&lt;/span&gt;
  &lt;span class=&quot;pi&quot;&gt;-&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;master&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;把上面的 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;your_github_token&amp;gt;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;your_github_repo.git&amp;gt;&lt;/code&gt; 换成你自己的就好了（不用&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;&amp;gt;&lt;/code&gt;）。GitLab Pages 使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;public&lt;/code&gt; 文件夹展示生成的内容，所以要在 GitLab 上托管博客，就不要改这个文件夹了。&lt;/p&gt;

&lt;p&gt;然后就可以继续开开心心的弄博客啦，只需要把 Jekyll 文件推送到 GitLab 上，就能看到 GitHub 用生成的静态文件给你展示博客内容啦。当然，也可以用同样的方法推送到 Coding.net 上，我就这么做了，这下一次 push，几处都有了，也不用那么麻烦设置我现在还没懂的 Webhooks 了。&lt;/p&gt;

&lt;p&gt;当然，GitLab 提供免费的私人仓库，所以你不想共享博客源文件也可以用这种方法。PS，GitLab Pages 支持自定义域名使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;https&lt;/code&gt; ，👍。&lt;/p&gt;</content><author><name>Frank Lin</name></author><category term="Tips" /><category term="GitLab" /><category term="Jekyll" /><summary>由于一些莫名其妙的原因，我用 GitHub Pages 的 Jekyll 版本不能在本地生成 _posts 的静态文件，自然放到 GitHub 上也不行。一直没弄清楚原因，😳 求知情人士解答。于是找了备用方案，用起了 GitLab Pages，但是访问速度上又没有 GitHub Pages 给力，又不想用其他 CDN，所以还是两头托管，还能让百度索引。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201605/gitlab.png" /></entry><entry><title>Git 学习笔记 - 提交历史</title><link href="http://www.flinhong.com/tools/Git-notes-logs/" rel="alternate" type="text/html" title="Git 学习笔记 - 提交历史" /><published>2016-05-21T00:00:00+08:00</published><updated>2016-05-21T00:00:00+08:00</updated><id>http://www.flinhong.com/tools/Git-notes-logs</id><content type="html" xml:base="http://www.flinhong.com/tools/Git-notes-logs/">&lt;p&gt;在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 命令。&lt;/p&gt;

&lt;p&gt;接下来按照 Git Pro 中的演示例子 simplegit 项目，一步一步操作学习吧。运行下面的命令获取该项目源代码：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;git clone https://github.com/schacon/simplegit-progit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后在此项目中运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt;，应该会看到下面的输出：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git log
commit ca82a6dff817ec66f44342007202690a93763949
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Mon Mar 17 21:52:11 2008 -0700

    changed the version number

commit 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 16:40:33 2008 -0700

    removed unnecessary &lt;span class=&quot;nb&quot;&gt;test

&lt;/span&gt;commit a11bef06a3f659402fe7563abf99ad00de2209e6
Author: Scott Chacon &amp;lt;schacon@gee-mail.com&amp;gt;
Date:   Sat Mar 15 10:31:28 2008 -0700

    first commit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认不用任何参数的话，&lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 会按提交时间列出所有的更新，最近的更新排在最上面。正如你所看到的，这个命令会列出每个提交的 SHA-1 校验和、作者的名字和电子邮件地址、提交时间以及提交说明。&lt;/p&gt;

&lt;p&gt;一个常用的选项是 &lt;code class=&quot;highlighter-rouge&quot;&gt;-p&lt;/code&gt;，用来显示每次提交的内容差异。 你也可以加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt; 来仅显示最近两次提交：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log -p -2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该选项除了显示基本信息之外，还在附带了每次 commit 的变化。当进行代码审查，或者快速浏览某个搭档提交的 commit 所带来的变化的时候，这个参数就非常有用了。 你也可以为 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 附带一系列的总结性选项。比如说，如果你想看到每次提交的简略的统计信息，你可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--stat&lt;/code&gt; 选项：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log --stat
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;--stat&lt;/code&gt; 选项在每次提交的下面列出额所有被修改过的文件、有多少文件被修改了以及被修改过的文件的哪些行被移除或是添加了。在每次提交的最后还有一个总结。&lt;/p&gt;

&lt;p&gt;另外一个常用的选项是 &lt;code class=&quot;highlighter-rouge&quot;&gt;--pretty&lt;/code&gt;。这个选项可以指定使用不同于默认格式的方式展示提交历史。这个选项有一些内建的子选项供你使用。比如用 oneline 将每个提交放在一行显示，查看的提交数很大时非常有用。另外还有 &lt;code class=&quot;highlighter-rouge&quot;&gt;short&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;full&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;fuller&lt;/code&gt; 可以用，展示的信息或多或少有些不同。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log --pretty=oneline
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;但最有意思的是 &lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt;，可以定制要显示的记录格式。这样的输出对后期提取分析格外有用 — 因为你知道输出的格式不会随着 Git 的更新而发生改变：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git log --pretty&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;format:&lt;span class=&quot;s2&quot;&gt;&quot;%h - %an, %ar : %s&quot;&lt;/span&gt;
ca82a6d - Scott Chacon, 6 years ago : changed the version number
085bb3b - Scott Chacon, 6 years ago : removed unnecessary &lt;span class=&quot;nb&quot;&gt;test
&lt;/span&gt;a11bef0 - Scott Chacon, 6 years ago : first commit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下表是 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log --pretty=format&lt;/code&gt; 常用的选项：&lt;/p&gt;

&lt;hr /&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;strong&gt;选项&lt;/strong&gt;&lt;/th&gt;
      &lt;th style=&quot;text-align: left&quot;&gt;&lt;strong&gt;说明&lt;/strong&gt;&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%H&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提交对象（commit）的完整哈希字串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%h&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提交对象的简短哈希字串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%T&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;树对象（tree）的完整哈希字串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%t&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;树对象的简短哈希字串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%P&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;父对象（parent）的完整哈希字串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%p&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;父对象的简短哈希字串&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%an&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;作者（author）的名字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%ae&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;作者的电子邮件地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%ad&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;作者修订日期（可以用 –date= 选项定制格式）&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%ar&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;作者修订日期，按多久以前的方式显示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%cn&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提交者(committer)的名字&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%ce&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提交者的电子邮件地址&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%cd&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提交日期&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%cr&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提交日期，按多久以前的方式显示&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;%s&lt;/code&gt;&lt;/td&gt;
      &lt;td style=&quot;text-align: left&quot;&gt;提交说明&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;你一定奇怪 作者 和 提交者 之间究竟有何差别，其实作者指的是实际作出修改的人，提交者指的是最后将此工作成果提交到仓库的人。所以，当你为某个项目发布补丁，然后某个核心成员将你的补丁并入项目时，你就是作者，而那个核心成员就是提交者。&lt;/p&gt;

&lt;p&gt;当 &lt;code class=&quot;highlighter-rouge&quot;&gt;oneline&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;format&lt;/code&gt; 与另一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;log&lt;/code&gt; 选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;--graph&lt;/code&gt; 结合使用时尤其有用。这个选项添加了一些 ASCII 字符串来形象地展示你的分支、合并历史：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git log --pretty&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;format:&lt;span class=&quot;s2&quot;&gt;&quot;%h %s&quot;&lt;/span&gt; --graph
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 2d3acf9 ignore errors from SIGCHLD on &lt;span class=&quot;nb&quot;&gt;trap&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  5e3ee11 Merge branch &lt;span class=&quot;s1&quot;&gt;&#39;master&#39;&lt;/span&gt; of git://github.com/dustin/grit
|&lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
| &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 420eac9 Added a method &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;getting the current branch.
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; | 30e367c timeout code and tests
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; | 5a09431 add timeout protection to grit
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; | e1193f8 support &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;heads with slashes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;them
|/
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; d6016bc require &lt;span class=&quot;nb&quot;&gt;time &lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;xmlschema
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;  11d191e Merge branch &lt;span class=&quot;s1&quot;&gt;&#39;defunkt&#39;&lt;/span&gt; into &lt;span class=&quot;nb&quot;&gt;local&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;以上只是简单介绍了一些 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 命令支持的选项。这有个&lt;a href=&quot;https://git-scm.com/book/zh/v2/ch00/log_options&quot;&gt;表格&lt;/a&gt;列出了我们目前涉及到的和没涉及到的选项，以及它们是如何影响 log 命令的输出的。&lt;/p&gt;

&lt;p&gt;除了定制输出格式的选项之外，&lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。之前你已经看到过 &lt;code class=&quot;highlighter-rouge&quot;&gt;-2&lt;/code&gt; 了，它只显示最近的两条提交，实际上，这是 &lt;code class=&quot;highlighter-rouge&quot;&gt;-&amp;lt;n&amp;gt;&lt;/code&gt; 选项的写法，其中的 n 可以是任何整数，表示仅显示最近的若干条提交。不过实践中我们是不太用这个选项的，Git 在输出所有提交时会自动调用分页程序，所以你一次只会看到一页的内容。&lt;/p&gt;

&lt;p&gt;另外还有按照时间作限制的选项，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;--since&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;--until&lt;/code&gt; 也很有用。&lt;/p&gt;

&lt;p&gt;还可以给出若干搜索条件，列出符合的提交。用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--author&lt;/code&gt; 选项显示指定作者的提交，用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--grep&lt;/code&gt; 选项搜索提交说明中的关键字。（请注意，如果要得到同时满足这两个选项搜索条件的提交，就必须用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--all-match&lt;/code&gt; 选项。否则，满足任意一个条件的提交都会被匹配出来）&lt;/p&gt;

&lt;p&gt;另一个非常有用的筛选选项是 &lt;code class=&quot;highlighter-rouge&quot;&gt;-S&lt;/code&gt;，可以列出那些添加或移除了某些字符串的提交。比如说，你想找出添加或移除了某一个特定函数的引用的提交，你可以这样使用：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git log -Sfunction_name
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;最后一个很实用的 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 选项是路径 (path)，如果只关心某些文件或者目录的历史提交，可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;git log&lt;/code&gt; 选项的最后指定它们的路径。因为是放在最后位置上的选项，所以用两个短划线（–）隔开之前的选项和后面限定的路径名。&lt;/p&gt;

&lt;p&gt;来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试文件，可以用下面的查询命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git log --pretty&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%h - %s&quot;&lt;/span&gt; --author&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;gitster --since&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2008-10-01&quot;&lt;/span&gt; &lt;span class=&quot;se&quot;&gt;\&lt;/span&gt;
   --before&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;2008-11-01&quot;&lt;/span&gt; --no-merges -- t/
5610e3b - Fix testcase failure when extended attributes are &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;use
acd3b9e - Enhance hold_lock_file_for_&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;update,append&lt;span class=&quot;o&quot;&gt;}()&lt;/span&gt; API
f563754 - demonstrate breakage of detached checkout with symbolic link HEAD
d1a43f2 - reset --hard/read-tree --reset -u: remove unmerged new paths
51a94af - Fix &lt;span class=&quot;s2&quot;&gt;&quot;checkout --track -b newbranch&quot;&lt;/span&gt; on detached HEAD
b0ad11e - pull: allow &lt;span class=&quot;s2&quot;&gt;&quot;git pull origin &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$something&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;$current_branch&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt; into an unborn branch
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这次就到这里，有很多 GUI 都能可视化显示这些记录，看起来会比较贴心些，不过不都是基于这些命令的基础嘛，多学学还是有用的。&lt;/p&gt;</content><author><name>Frank Lin</name></author><category term="Tools" /><category term="Git" /><summary>在提交了若干更新，又或者克隆了某个项目之后，你也许想回顾下提交历史。完成这个任务最简单而又有效的工具是 git log 命令。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201605/git-log.jpg" /></entry><entry><title>Git 学习笔记 - Git 基础</title><link href="http://www.flinhong.com/tools/Git-notes-basics/" rel="alternate" type="text/html" title="Git 学习笔记 - Git 基础" /><published>2016-05-20T00:00:00+08:00</published><updated>2016-05-20T00:00:00+08:00</updated><id>http://www.flinhong.com/tools/Git-notes-basics</id><content type="html" xml:base="http://www.flinhong.com/tools/Git-notes-basics/">&lt;p&gt;今天学习 Git 仓库的基本操作：初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改，配置 Git 来忽略指定的文件和文件模式，以及在仓库中移动、移除文件。&lt;/p&gt;

&lt;h2 id=&quot;headid-git-&quot;&gt;获取 Git 仓库&lt;/h2&gt;

&lt;h3 id=&quot;headid-section&quot;&gt;在现有目录中初始化仓库&lt;/h3&gt;

&lt;p&gt;如果你打算使用 Git 来对现有的项目进行管理，你只需要进入该项目目录并输入：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git init
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该命令将创建一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.git&lt;/code&gt; 的子目录，这个子目录含有你初始化的 Git 仓库中所有的必须文件，这些文件是 Git 仓库的骨干。 但是，在这个时候，我们仅仅是做了一个初始化的操作，你的项目里的文件还没有被跟踪。你可通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 命令来实现对指定文件的跟踪，然后执行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 提交：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.c
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add LICENSE
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -m &lt;span class=&quot;s1&quot;&gt;&#39;initial project version&#39;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;headid-section-1&quot;&gt;克隆现有的仓库&lt;/h3&gt;

&lt;p&gt;这也是我最常用的，在 Github 上建好仓库后，用克隆的方法可以不用怎么配置就能直接推送了。&lt;/p&gt;

&lt;p&gt;克隆仓库的命令格式是 &lt;code class=&quot;highlighter-rouge&quot;&gt;git clone [url]&lt;/code&gt;。比如，要克隆 Git 的可链接库 libgit2，可以用下面的命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git clone https://github.com/libgit2/libgit2
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这会在当前目录下创建一个名为 “libgit2” 的目录，并在这个目录下初始化一个 .git 文件夹，从远程仓库拉取下所有数据放入 .git 文件夹，然后从中读取最新版本的文件的拷贝。如果你想在克隆远程仓库的时候，自定义本地仓库的名字，你可以使用如下命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git clone https://github.com/libgit2/libgit2 mylibgit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;headid-section-2&quot;&gt;记录每次更新到仓库&lt;/h2&gt;

&lt;p&gt;你工作目录下的每一个文件都不外乎这两种状态：已跟踪或未跟踪。已跟踪的文件是指那些被纳入了版本控制的文件，在上一次快照中有它们的记录，在工作一段时间后，它们的状态可能处于未修改，已修改或已放入暂存区。工作目录中除已跟踪文件以外的所有其它文件都属于未跟踪文件，它们既不存在于上次快照的记录中，也没有放入暂存区。初次克隆某个仓库的时候，工作目录中的所有文件都属于已跟踪文件，并处于未修改状态。&lt;/p&gt;

&lt;p&gt;编辑过某些文件之后，由于自上次提交后你对它们做了修改，Git 将它们标记为已修改文件。我们逐步将这些修改过的文件放入暂存区，然后提交所有暂存了的修改，如此反复。所以使用 Git 时文件的生命周期如下：&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201605/lifecycle.png&quot; alt=&quot;Git 文件周期&quot; title=&quot;Git 中文件的状态变化周期&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;headid-section-3&quot;&gt;检查当前文件状态&lt;/h3&gt;

&lt;p&gt;要查看哪些文件处于什么状态，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令。如果在克隆仓库后立即使用此命令，会看到类似这样的输出：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
nothing to commit, working directory clean
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;现在，让我们在项目下创建一个新的 README 文件。如果之前并不存在这个文件，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令，你将看到一个新的未跟踪文件：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s1&quot;&gt;&#39;My Project&#39;&lt;/span&gt; &amp;gt; README
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
Untracked files:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to include &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    README

nothing added to commit but untracked files present &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add&quot;&lt;/span&gt; to track&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;在状态报告中可以看到新建的 README 文件出现在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Untracked files&lt;/code&gt; 下面。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-4&quot;&gt;跟踪新文件&lt;/h3&gt;

&lt;p&gt;要跟踪 README 文件，就要使用命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 将其纳入跟踪。 运行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;此时再运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令，会看到 README 文件已被跟踪，并处于暂存状态：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
Changes to be committed:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git reset HEAD &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to unstage&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    new file:   README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;只要在 &lt;code class=&quot;highlighter-rouge&quot;&gt;Changes to be committed&lt;/code&gt; 这行下面的，就说明是已暂存状态。如果此时提交，那么该文件此时此刻的版本将被留存在历史记录中。&lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 命令使用文件或目录的路径作为参数；如果参数是目录的路径，该命令将递归地跟踪该目录下的所有文件。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-5&quot;&gt;暂存已修改文件&lt;/h3&gt;

&lt;p&gt;修改文件之后，要暂存这次更新，需要运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 命令。这是个多功能命令：可以用它开始跟踪新文件，或者把已跟踪的文件放到暂存区，还能用于合并时把有冲突的文件标记为已解决状态等。将这个命令理解为“添加内容到下一次提交中”而不是“将一个文件添加到项目中”要更加合适。&lt;/p&gt;

&lt;p&gt;如果运行了 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 之后又作了修订的文件，需要重新运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 把最新版本重新暂存起来。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-6&quot;&gt;状态简览&lt;/h3&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令的输出十分详细，但其用语有些繁琐。如果你使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status -s&lt;/code&gt; 命令或 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status --short&lt;/code&gt; 命令，你将得到一种更为紧凑的格式输出，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;新添加的未跟踪文件前面有 &lt;code class=&quot;highlighter-rouge&quot;&gt;??&lt;/code&gt; 标记，新添加到暂存区中的文件前面有 &lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt; 标记，修改过的文件前面有 &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; 标记。 你可能注意到了 &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; 有两个可以出现的位置，出现在右边的 &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; 表示该文件被修改了但是还没放入暂存区，出现在靠左边的 &lt;code class=&quot;highlighter-rouge&quot;&gt;M&lt;/code&gt; 表示该文件被修改了并放入了暂存区。例如，上面的状态报告显示： README 文件在工作区被修改了但是还没有将修改后的文件放入暂存区, lib/simplegit.rb 文件被修改了并将修改后的文件放入了暂存区。而 Rakefile 在工作区被修改并提交到暂存区后又在工作区中被修改了，所以在暂存区和工作区都有该文件被修改了的记录。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-7&quot;&gt;忽略文件&lt;/h3&gt;

&lt;p&gt;一般我们总会有些文件无需纳入 Git 的管理，也不希望它们总出现在未跟踪文件列表，比如日志文件，或者编译过程中创建的临时文件等。在这种情况下，我们可以创建一个名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 的文件，列出要忽略的文件模式。来看一个实际的例子：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;cat .gitignore
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;.[oa]
&lt;span class=&quot;k&quot;&gt;*&lt;/span&gt;~
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;第一行告诉 Git 忽略所有以 &lt;code class=&quot;highlighter-rouge&quot;&gt;.o&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;.a&lt;/code&gt; 结尾的文件。一般这类对象文件和存档文件都是编译过程中出现的。第二行告诉 Git 忽略所有以波浪符（~）结尾的文件，许多文本编辑软件（比如 Emacs）都用这样的文件名保存副本。&lt;/p&gt;

&lt;p&gt;文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 的格式规范如下：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;所有空行或者以 ＃ 开头的行都会被 Git 忽略。&lt;/li&gt;
  &lt;li&gt;可以使用标准的 glob 模式匹配。&lt;/li&gt;
  &lt;li&gt;匹配模式可以以（/）开头防止递归。&lt;/li&gt;
  &lt;li&gt;匹配模式可以以（/）结尾指定目录。&lt;/li&gt;
  &lt;li&gt;要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;所谓的 glob 模式是指 shell 所使用的简化了的正则表达式。星号 (&lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt;) 匹配零个或多个任意字符； [&lt;code class=&quot;highlighter-rouge&quot;&gt;abc&lt;/code&gt;] 匹配任何一个列在方括号中的字符（这个例子要么匹配一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;a&lt;/code&gt;，要么匹配一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;b&lt;/code&gt;，要么匹配一个 &lt;code class=&quot;highlighter-rouge&quot;&gt;c&lt;/code&gt;）；问号（&lt;code class=&quot;highlighter-rouge&quot;&gt;?&lt;/code&gt;）只匹配一个任意字符；如果在方括号中使用短划线分隔两个字符，表示所有在这两个字符范围内的都可以匹配（比如 [&lt;code class=&quot;highlighter-rouge&quot;&gt;0-9&lt;/code&gt;] 表示匹配所有 &lt;code class=&quot;highlighter-rouge&quot;&gt;0&lt;/code&gt; 到 &lt;code class=&quot;highlighter-rouge&quot;&gt;9&lt;/code&gt; 的数字）。使用两个星号（&lt;code class=&quot;highlighter-rouge&quot;&gt;**&lt;/code&gt;) 表示匹配任意中间目录，比如 &lt;code class=&quot;highlighter-rouge&quot;&gt;a/**/z&lt;/code&gt; 可以匹配 &lt;code class=&quot;highlighter-rouge&quot;&gt;a/z&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;a/b/z&lt;/code&gt; 或 &lt;code class=&quot;highlighter-rouge&quot;&gt;a/b/c/z&lt;/code&gt; 等。&lt;/p&gt;

&lt;p&gt;GitHub 有一个十分详细的针对数十种项目及语言的 &lt;code class=&quot;highlighter-rouge&quot;&gt;.gitignore&lt;/code&gt; 文件列表，你可以在 &lt;a href=&quot;https://github.com/github/gitignore&quot;&gt;https://github.com/github/gitignore&lt;/a&gt; 找到它。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-8&quot;&gt;查看已暂存和未暂存的修改&lt;/h3&gt;

&lt;p&gt;如果 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 命令的输出对于你来说过于模糊，你想知道具体修改了什么地方，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt; 命令。你可能通常会用它来回答这两个问题：当前做的哪些更新还没有暂存？ 有哪些更新已经暂存起来准备好了下次提交？&lt;/p&gt;

&lt;p&gt;此命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化内容。&lt;/p&gt;

&lt;p&gt;若要查看已暂存的将要添加到下次提交里的内容，可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git diff --cached&lt;/code&gt; 命令。（Git 1.6.1 及更高版本还允许使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git diff --staged&lt;/code&gt;，效果是相同的，但更好记些。）&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt; 本身只显示尚未暂存的改动，而不是自上次提交以来所做的所有改动。所以有时候你一下子暂存了所有更新过的文件后，运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git diff&lt;/code&gt; 后却什么也没有，就是这个原因。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-9&quot;&gt;提交更新&lt;/h3&gt;

&lt;p&gt;每次准备提交前，先用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 看下，是不是都已暂存起来了，然后再运行提交命令 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt;：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这种方式会启动文本编辑器以便输入本次提交的说明。&lt;/p&gt;

&lt;p&gt;另外，你也可以在 &lt;code class=&quot;highlighter-rouge&quot;&gt;commit&lt;/code&gt; 命令后添加 &lt;code class=&quot;highlighter-rouge&quot;&gt;-m&lt;/code&gt; 选项，将提交信息与命令放在同一行，如下所示：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -m &lt;span class=&quot;s2&quot;&gt;&quot;Story 182: Fix benchmarks for speed&quot;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;master 463dc4f] Story 182: Fix benchmarks &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;speed
 2 files changed, 2 insertions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
 create mode 100644 README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;OK，现在你已经创建了第一个提交！可以看到，提交后它会告诉你，当前是在哪个分支（master）提交的，本次提交的完整 SHA-1 校验和是什么（463dc4f），以及在本次提交中，有多少文件修订过，多少行添加和删改过。&lt;/p&gt;

&lt;p&gt;要注意，提交时记录的是放在暂存区域的快照。任何还未暂存的仍然保持已修改状态，可以在下次提交时纳入版本管理。每一次运行提交操作，都是对你项目作一次快照，以后可以回到这个状态，或者进行比较。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-10&quot;&gt;跳过使用暂存区域&lt;/h3&gt;

&lt;p&gt;尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。 Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候，给 &lt;code class=&quot;highlighter-rouge&quot;&gt;git commit&lt;/code&gt; 加上 &lt;code class=&quot;highlighter-rouge&quot;&gt;-a&lt;/code&gt; 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 步骤：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
Changes not staged &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;commit:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to update what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git checkout -- &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to discard changes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;working directory&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    modified:   CONTRIBUTING.md

no changes added to commit &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add&quot;&lt;/span&gt; and/or &lt;span class=&quot;s2&quot;&gt;&quot;git commit -a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git commit -a -m &lt;span class=&quot;s1&quot;&gt;&#39;added new benchmarks&#39;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;master 83e38c7] added new benchmarks
 1 file changed, 5 insertions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;+&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 0 deletions&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;-&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如此，提交之前不再需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;git add&lt;/code&gt; 文件“CONTRIBUTING.md”了。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-11&quot;&gt;移除文件&lt;/h3&gt;

&lt;p&gt;要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除（确切地说，是从暂存区域移除），然后提交。可以用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt; 命令完成此项工作，并连带从工作目录中删除指定的文件，这样以后就不会出现在未跟踪文件清单中了。&lt;/p&gt;

&lt;p&gt;如果只是简单地从工作目录中手工删除文件，运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git status&lt;/code&gt; 时就会在 “Changes not staged for commit” 部分（也就是 未暂存清单）看到：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;rm PROJECTS.md
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
Your branch is up-to-date with &lt;span class=&quot;s1&quot;&gt;&#39;origin/master&#39;&lt;/span&gt;.
Changes not staged &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;commit:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add/rm &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to update what will be committed&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git checkout -- &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to discard changes &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;working directory&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

        deleted:    PROJECTS.md

no changes added to commit &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git add&quot;&lt;/span&gt; and/or &lt;span class=&quot;s2&quot;&gt;&quot;git commit -a&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;然后再运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt; 记录此次移除文件的操作：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git rm PROJECTS.md
rm &lt;span class=&quot;s1&quot;&gt;&#39;PROJECTS.md&#39;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git status
On branch master
Changes to be committed:
  &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;use &lt;span class=&quot;s2&quot;&gt;&quot;git reset HEAD &amp;lt;file&amp;gt;...&quot;&lt;/span&gt; to unstage&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

    deleted:    PROJECTS.md
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;下一次提交时，该文件就不再纳入版本管理了。如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 &lt;code class=&quot;highlighter-rouge&quot;&gt;-f&lt;/code&gt;。 这是一种安全特性，用于防止误删还没有添加到快照的数据，这样的数据不能被 Git 恢复。&lt;/p&gt;

&lt;p&gt;另外一种情况是，我们想把文件从 Git 仓库中删除（亦即从暂存区域移除），但仍然希望保留在当前工作目录中。换句话说，你想让文件保留在磁盘，但是并不想让 Git 继续跟踪。当你忘记添加 .gitignore 文件，不小心把一个很大的日志文件或一堆 &lt;code class=&quot;highlighter-rouge&quot;&gt;.a&lt;/code&gt; 这样的编译生成文件添加到暂存区时，这一做法尤其有用。为达到这一目的，使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;--cached&lt;/code&gt; 选项：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git rm --cached README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;git rm&lt;/code&gt; 命令后面可以列出文件或者目录的名字，也可以使用上面提到的 &lt;code class=&quot;highlighter-rouge&quot;&gt;glob&lt;/code&gt; 模式。&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git rm log/&lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt;.log
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;注意星号 &lt;code class=&quot;highlighter-rouge&quot;&gt;*&lt;/code&gt; 之前的反斜杠 &lt;code class=&quot;highlighter-rouge&quot;&gt;\&lt;/code&gt;， 因为 Git 有它自己的文件模式扩展匹配方式，所以我们不用 &lt;code class=&quot;highlighter-rouge&quot;&gt;shell&lt;/code&gt; 来帮忙展开。此命令删除 &lt;code class=&quot;highlighter-rouge&quot;&gt;log/&lt;/code&gt; 目录下扩展名为 &lt;code class=&quot;highlighter-rouge&quot;&gt;.log&lt;/code&gt; 的所有文件。类似的比如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git rm &lt;span class=&quot;se&quot;&gt;\*&lt;/span&gt;~
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;该命令为删除以 &lt;code class=&quot;highlighter-rouge&quot;&gt;~&lt;/code&gt; 结尾的所有文件。&lt;/p&gt;

&lt;h3 id=&quot;headid-section-12&quot;&gt;修改文件名&lt;/h3&gt;

&lt;p&gt;要在 Git 中对文件改名，可以这么做：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git mv file_from file_to
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;它会恰如预期般正常工作。 实际上，即便此时查看状态信息，也会明白无误地看到关于重命名操作的说明：&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ git mv README.md README
$ git status
On branch master
Changes to be committed:
  (use &quot;git reset HEAD &amp;lt;file&amp;gt;...&quot; to unstage)

    renamed:    README.md -&amp;gt; README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;其实，运行 &lt;code class=&quot;highlighter-rouge&quot;&gt;git mv&lt;/code&gt; 就相当于运行了下面三条命令：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;mv README.md README
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git rm README.md
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git add README
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;学完这些，突然觉得还是 GUI 好用…… 😂&lt;/p&gt;</content><author><name>Frank Lin</name></author><category term="Tools" /><category term="Git" /><summary>今天学习 Git 仓库的基本操作：初始化一个仓库（repository）、开始或停止跟踪（track）文件、暂存（stage）或提交（commit)更改，配置 Git 来忽略指定的文件和文件模式，以及在仓库中移动、移除文件。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201605/git-history.png" /></entry><entry><title>Git 学习笔记 - 起步</title><link href="http://www.flinhong.com/tools/Git-notes-start/" rel="alternate" type="text/html" title="Git 学习笔记 - 起步" /><published>2016-05-19T00:00:00+08:00</published><updated>2016-05-19T00:00:00+08:00</updated><id>http://www.flinhong.com/tools/Git-notes-start</id><content type="html" xml:base="http://www.flinhong.com/tools/Git-notes-start/">&lt;p&gt;虽然一直用 Git 管理自己的博客文件，但大多数情况下使用的是 Github Desktop 或者 Git GUI，对 Git 本身以及 Git 的一些命令并不理解。所以找到 &lt;a href=&quot;https://git-scm.com/book/en/v2&quot;&gt;Pro Git&lt;/a&gt; 深入学习一下 Git。&lt;/p&gt;

&lt;h2 id=&quot;headid-git-&quot;&gt;Git 如何对待数据&lt;/h2&gt;

&lt;p&gt;Git 和其它版本控制系统（包括 Subversion 和近似工具）的主要差别在于 Git 对待数据的方法。Git 中把数据看作是对小型文件系统的一组快照。每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。Git 对待数据更像是一个“&lt;strong&gt;快照流&lt;/strong&gt;”。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201605/git-ver-time.png&quot; alt=&quot;Git data over time&quot; title=&quot;存储项目随时间改变的快照&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;headid-git--1&quot;&gt;数据在 Git 中的三种状态&lt;/h2&gt;

&lt;p&gt;在 Git 中，你的文件可能处于三种状态中的其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。已提交表示数据已经安全的保存在本地数据库中。已修改表示修改了文件，但还没保存到数据库中。已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。&lt;/p&gt;

&lt;p&gt;由此引入 Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域。&lt;/p&gt;

&lt;p class=&quot;hascaption&quot;&gt;&lt;img src=&quot;/images/201605/git-area.png&quot; alt=&quot;3 status in Git&quot; title=&quot;工作目录、暂存区域以及 Git 仓库&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。&lt;/p&gt;

&lt;p&gt;工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。&lt;/p&gt;

&lt;p&gt;暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。有时候也被称作“索引”，不过一般说法还是叫暂存区域。&lt;/p&gt;

&lt;p&gt;基本的 Git 工作流程如下：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;在工作目录中修改文件。&lt;/li&gt;
  &lt;li&gt;暂存文件，将文件的快照放入暂存区域。&lt;/li&gt;
  &lt;li&gt;提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;在 Git 目录中保存着的特定版本文件，就属于已提交状态。如果作了修改并已放入暂存区域，就属于已暂存状态。如果自上次取出后，作了修改但还没有放到暂存区域，就是已修改状态。&lt;/p&gt;

&lt;h2 id=&quot;headid-git--2&quot;&gt;初次运行 Git 前的配置&lt;/h2&gt;

&lt;p&gt;在不同系统安装 Git 可参考 &lt;a href=&quot;https://git-scm.com/book/zh/v2/%E8%B5%B7%E6%AD%A5-%E5%AE%89%E8%A3%85-Git&quot;&gt;Git 官方网站&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;安装完 Git 后应该做的第一件事就是设置你的用户名称与邮件地址。这样做很重要，因为每一个 Git 的提交都会使用这些信息，并且它会写入到你的每一次提交中，不可更改：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git config --global user.name &lt;span class=&quot;s2&quot;&gt;&quot;Frank Lin&quot;&lt;/span&gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git config --global user.email franklin@flinhong.com
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;如果想要检查你的配置，可以使用 &lt;code class=&quot;highlighter-rouge&quot;&gt;git config --list&lt;/code&gt; 命令来列出所有 Git 当时能找到的配置。通过输入 &lt;code class=&quot;highlighter-rouge&quot;&gt;git config &amp;lt;key&amp;gt;&lt;/code&gt; 来检查 Git 的某一项配置，例如：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git config user.name
Frank Lin
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;headid-section&quot;&gt;获取帮助&lt;/h2&gt;

&lt;p&gt;有三种方法可以找到 Git 命令的使用手册：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git &lt;span class=&quot;nb&quot;&gt;help&lt;/span&gt; &amp;lt;verb&amp;gt;
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git &amp;lt;verb&amp;gt; --help
&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;man git-&amp;lt;verb&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;例如，要想获得 config 命令的手册，执行：&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;gp&quot;&gt;$ &lt;/span&gt;git &lt;span class=&quot;nb&quot;&gt;help &lt;/span&gt;config
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;这些命令可以随时随地使用而无需联网。&lt;/p&gt;</content><author><name>Frank Lin</name></author><category term="Tools" /><category term="Git" /><summary>虽然一直用 Git 管理自己的博客文件，但大多数情况下使用的是 Github Desktop 或者 Git GUI，对 Git 本身以及 Git 的一些命令并不理解。所以找到 Pro Git 深入学习一下 Git。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201605/git-start.jpg" /></entry><entry><title>Hello World! - Again</title><link href="http://www.flinhong.com/learning/hello-world-again/" rel="alternate" type="text/html" title="Hello World! - Again" /><published>2016-05-18T00:00:00+08:00</published><updated>2016-05-18T00:00:00+08:00</updated><id>http://www.flinhong.com/learning/hello-world-again</id><content type="html" xml:base="http://www.flinhong.com/learning/hello-world-again/">&lt;p&gt;没想到学一门语言都跳票多次，真是惭愧惭愧！这次是真的下定决心好好学习一下 C# 了，我就不信我坚持不下去。&lt;/p&gt;

&lt;p&gt;这个进度我就不敢保证了，毕竟平时要忙实验，尽量抽空学吧。这里也做下学习笔记，督促督促自己。&lt;/p&gt;

&lt;p&gt;这次参考书籍是 &lt;a href=&quot;https://www.microsoftpressstore.com/store/microsoft-visual-c-sharp-2013-step-by-step-9780735681835&quot;&gt;Microsoft Visual C# 2013&lt;/a&gt;，同时参考 &lt;a href=&quot;https://courses.edx.org/courses/course-v1:Microsoft+DEV204x+2T2016/info&quot;&gt;Microsoft’s DEV204x&lt;/a&gt; 课程，就由这里起步吧。&lt;/p&gt;

&lt;p&gt;虽说 &lt;code class=&quot;highlighter-rouge&quot;&gt;Hello World!&lt;/code&gt; 见了不知多少次了，但是这么具有标志性，我也来段纪念纪念。&lt;/p&gt;

&lt;div class=&quot;language-c# highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Collections.Generic&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Linq&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Text&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;using&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;System.Threading.Tasks&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;namespace&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;TestHello&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Program&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Main&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;string&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Hello World!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;WriteLine&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;Just do it, Frank!&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Console&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;nf&quot;&gt;ReadKey&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>Frank Lin</name></author><category term="Learning" /><category term="C#" /><summary>没想到学一门语言都跳票多次，真是惭愧惭愧！这次是真的下定决心好好学习一下 C# 了，我就不信我坚持不下去。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201605/csharp.jpg" /></entry><entry><title>在 Sublime Text 中用 Markdown 编辑 Evernote 笔记</title><link href="http://www.flinhong.com/tools/Sublime-Evernote/" rel="alternate" type="text/html" title="在 Sublime Text 中用 Markdown 编辑 Evernote 笔记" /><published>2016-05-16T00:00:00+08:00</published><updated>2016-05-16T00:00:00+08:00</updated><id>http://www.flinhong.com/tools/Sublime-Evernote</id><content type="html" xml:base="http://www.flinhong.com/tools/Sublime-Evernote/">&lt;p&gt;某个风和日丽的下午，一学妹问我有没有什么好用的笔记软件，但不要 Evernote 和 OneNote。一时语塞，除了这两个常用的笔记软件，我也提不出其他比较靠谱的了，知之甚少。&lt;/p&gt;

&lt;p&gt;虽然自己也时有做笔记，但多数时间是用 Evernote 摘录网页，以作备用。为了回答学妹的问题，我也试着搜索了一下。&lt;a href=&quot;http://www.appinn.com/my-fav-note-final/&quot;&gt;小众软件&lt;/a&gt;曾票选过最受欢迎的笔记软件，还是 Evernote 最受青睐，OneNote 也还不错，其他的基本没用过也不做评价。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-ofBR5thsjtU/VznEZr5z6TI/AAAAAAAAAYM/CmXFgB4Grkk/s0/Note%252520Apps.png&quot; alt=&quot;最受欢迎的笔记软件&quot; /&gt;&lt;/p&gt;

&lt;p&gt;既然 Evernote 最常用，那还是选择它吧。但是 Evernote 对 Markdown 支持不是很到位，更不要说 OneNote 了。所以有不少同学选择在 GitHub 上做起笔记来。这倒也可以，不过自己要看个笔记还得去翻网页就不太方便了。所以有了今天这款 &lt;a href=&quot;https://packagecontrol.io/packages/Evernote&quot;&gt;Evernote for Sublime Text&lt;/a&gt; 插件。&lt;/p&gt;

&lt;h2 id=&quot;headid-section&quot;&gt;简介&lt;/h2&gt;

&lt;p&gt;Evernote for Sublime Text 做到的是在 Sublime Text 中编辑 Markdown 文本，本地保存（可用 OneDrive, GitHub 等做同步备份）原始文本，并和 Evernote 笔记 ID 关联同步。这样，在 Sublime 中可以浏览由 Sublime 创建的 Markdown 文件，又能将转换后的笔记同步到 Evernote 的笔记列表，还可进行双向同步（在 Sublime 中打开 Evernote 的笔记并转换成 Markdown 进行编辑）。不过，在使用过程中，一旦在 Evernote 中对笔记进行了更新，则有一定几率导致笔记同步冲突&lt;sup id=&quot;fnref:1&quot;&gt;&lt;a href=&quot;#fn:1&quot; class=&quot;footnote&quot;&gt;1&lt;/a&gt;&lt;/sup&gt;。Markdown 标记错误也能引起不能同步。&lt;/p&gt;

&lt;p&gt;自己试用了一下，感觉用 Markdown 这样做笔记确实很方便，同步冲突也确实遇到了（代码高亮的时候写错了语言名称），不过这不影响我继续使用这个优秀的插件。在编辑过程中注意不要修改 Evernote 中的笔记就是了（那就暂时不打开 Evernote吧）。若今后修改了 Evernote 中的笔记，最好使用插件的打开命令，打开一份新的再继续编辑更新吧。&lt;/p&gt;

&lt;h2 id=&quot;headid-section-1&quot;&gt;安装&lt;/h2&gt;

&lt;p&gt;那么，来看看这款插件的使用吧。首先是&lt;a href=&quot;https://github.com/bordaigorl/sublime-evernote/wiki/Installation&quot;&gt;安装&lt;/a&gt;：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;用 Sublime Text 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Package Control&lt;/code&gt; 安装 Evernote。如果你在 Sublime Text 中没有安装过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Package Control&lt;/code&gt;，请参见这里的&lt;a href=&quot;https://packagecontrol.io/installation&quot;&gt;安装指南&lt;/a&gt;。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;设置 Sublime Text 插件与 Evernote 关联&lt;sup id=&quot;fnref:2&quot;&gt;&lt;a href=&quot;#fn:2&quot; class=&quot;footnote&quot;&gt;2&lt;/a&gt;&lt;/sup&gt;：&lt;/p&gt;

    &lt;p&gt;(1) 关联 Evernote 需要 &lt;code class=&quot;highlighter-rouge&quot;&gt;Developer Token&lt;/code&gt;，如果第一次关联或者要更新 Token，可以通过 Sublime Text 菜单中的 &lt;code class=&quot;highlighter-rouge&quot;&gt;Preferences &amp;gt; Package Settings &amp;gt; Evernote &amp;gt; Reconfigure Evernote&lt;/code&gt; 打开 Evernote 的相应页面获取应用授权。&lt;/p&gt;

    &lt;p&gt;&lt;img src=&quot;https://lh3.googleusercontent.com/-eX1AQnGrvuQ/VznMqCedygI/AAAAAAAAAYc/2Tpri7no2ek/s0/sublime_text_2016-05-16_21-35-33.png&quot; alt=&quot;关联 Evernote&quot; /&gt;&lt;/p&gt;

    &lt;p&gt;(2) 如果是中国印象笔记的用户，需&lt;a href=&quot;https://github.com/bordaigorl/sublime-evernote/wiki/First-Use#%E4%B8%AD%E5%9B%BD%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%E7%94%A8%E6%88%B7appyinxiangcom&quot;&gt;参见这里&lt;/a&gt;进行关联设置。&lt;/p&gt;

    &lt;p&gt;(3) 将 Evernote 网页中的 Developer Token 和 NoteStore URL 添加到 Sublime Evernote 插件的设置文件 &lt;code class=&quot;highlighter-rouge&quot;&gt;Preferences &amp;gt; Package Settings &amp;gt; Evernote &amp;gt; Settings - User&lt;/code&gt;：&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;noteStoreUrl&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Your NoteStore URL&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
  &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;token&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Your Developer Token&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
 &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;测试是否成功：通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+shift+p&lt;/code&gt; (Win, Linux) 或者 &lt;code class=&quot;highlighter-rouge&quot;&gt;shift+command+p&lt;/code&gt; (OS X) 打开 Sublime Text 命令窗口，输入 Evernote，就会看见 Evernote 插件的许多命令，点击 Evernote:list recent notes，如果看到罗列出最新的笔记，则说明授权成功。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;headid-section-2&quot;&gt;快捷键设置&lt;/h2&gt;

&lt;p&gt;默认情况下，Evernote 插件没有绑定任何快捷键，所有操作通过 Sublime 中 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+shift+p&lt;/code&gt; 输入 Evenote 后选择相应功能进行。当然你也可以在 Sublime Text 中通过 &lt;code class=&quot;highlighter-rouge&quot;&gt;Preferences &amp;gt; Key Bindings - User&lt;/code&gt; 关联快捷键&lt;sup id=&quot;fnref:3&quot;&gt;&lt;a href=&quot;#fn:3&quot; class=&quot;footnote&quot;&gt;3&lt;/a&gt;&lt;/sup&gt;:&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;keys&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;super+e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;command&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;show_overlay&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;args&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;overlay&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;command_palette&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;text&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;Evernote: &quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;keys&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ctrl+e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ctrl+s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;command&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;send_to_evernote&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;keys&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ctrl+e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ctrl+o&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;command&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;open_evernote_note&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;keys&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ctrl+e&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;ctrl+u&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;],&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&quot;command&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;save_evernote_note&quot;&lt;/span&gt;&lt;span class=&quot;w&quot;&gt; &lt;/span&gt;&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;err&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;w&quot;&gt;
&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;意思是，按 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+e&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+s&lt;/code&gt; 后，会将笔记保存并且同步到印象笔记，按 &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+e&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ctrl+s&lt;/code&gt; 则是更新笔记。&lt;/p&gt;

&lt;p&gt;嗯，差不多这样就可以开始使用了，更多功能参看 Evernote for Sublime Text 的 &lt;a href=&quot;https://github.com/bordaigorl/sublime-evernote/wiki&quot;&gt;Wiki&lt;/a&gt;。&lt;/p&gt;

&lt;p&gt;对我来说，既可以用 Markdown 写 Blog post 同步到 Gitlab，又可以同时在 Evernote 中做个备份，很不错了。&lt;/p&gt;

&lt;p&gt;参考:&lt;/p&gt;

&lt;div class=&quot;footnotes&quot;&gt;
  &lt;ol&gt;
    &lt;li id=&quot;fn:1&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://blog.ernest.me/post/evernote-starts-support-markdown&quot;&gt;从 Evernote 开始官方支持 Markdown 说起&lt;/a&gt; &lt;a href=&quot;#fnref:1&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:2&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;http://www.jianshu.com/p/0add426fdd26&quot;&gt;Sublime-evernote：支持用 Markdown 写印象笔记(Evernote)&lt;/a&gt; &lt;a href=&quot;#fnref:2&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
    &lt;li id=&quot;fn:3&quot;&gt;
      &lt;p&gt;&lt;a href=&quot;https://packagecontrol.io/packages/Evernote&quot;&gt;Evernote for Sublime Text&lt;/a&gt; &lt;a href=&quot;#fnref:3&quot; class=&quot;reversefootnote&quot;&gt;&amp;#8617;&lt;/a&gt;&lt;/p&gt;
    &lt;/li&gt;
  &lt;/ol&gt;
&lt;/div&gt;</content><author><name>Frank Lin</name></author><category term="Tools" /><category term="Sublime Text" /><category term="Evernote" /><summary>某个风和日丽的下午，一学妹问我有没有什么好用的笔记软件，但不要 Evernote 和 OneNote。一时语塞，除了这两个常用的笔记软件，我也提不出其他比较靠谱的了，知之甚少。</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://www.flinhong.com/images/201605/Evernote.jpg" /></entry></feed>
